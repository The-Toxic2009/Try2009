name: RDP-and-Drive-BiSync-Secondary-Continuous

on:
  workflow_dispatch:
    inputs:
      triggered_by:
        description: 'Workflow that triggered this run'
        required: true
        default: 'main'
      loop_id:
        description: 'Loop identifier for tracking'
        required: true
        default: 'secondary'
      timestamp:
        description: 'Trigger timestamp'
        required: false

jobs:
  rdp_bisync_secondary:
    runs-on: windows-latest
    timeout-minutes: 360  # Exactly 6 hours
    env:
      LOOP_ID: secondary
      RDP_USER: 'RDPUser'
      RDP_PASS: ${{ secrets.RDP_PASS }}
      TAILSCALE_AUTH_KEY: ${{ secrets.TAILSCALE_AUTH_KEY }}
      TAILSCALE_API_TOKEN: ${{ secrets.TAILSCALE_API_TOKEN }}
      GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
      GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
      GOOGLE_TOKEN: ${{ secrets.GOOGLE_TOKEN }}
      TRIGGERED_BY: ${{ github.event.inputs.triggered_by }}
      TRIGGER_TIMESTAMP: ${{ github.event.inputs.timestamp }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log Workflow Start
        shell: pwsh
        run: |
          Write-Host "üöÄ SECONDARY WORKFLOW STARTING" -ForegroundColor Green
          Write-Host "=============================" -ForegroundColor Green
          Write-Host "üîó Triggered by: $env:TRIGGERED_BY" -ForegroundColor Yellow
          Write-Host "üÜî Loop ID: ${{ github.event.inputs.loop_id }}" -ForegroundColor Yellow
          Write-Host "‚è∞ Trigger time: $env:TRIGGER_TIMESTAMP" -ForegroundColor Yellow
          Write-Host "üñ•Ô∏è  Runner: $env:RUNNER_NAME" -ForegroundColor Yellow
          Write-Host "=============================" -ForegroundColor Green

      - name: Cache Chocolatey packages
        uses: actions/cache@v4
        with:
          path: C:\ProgramData\chocolatey\lib
          key: ${{ runner.os }}-choco-secondary-${{ hashFiles('**/*.yml') }}
          restore-keys: |
            ${{ runner.os }}-choco-secondary-
            ${{ runner.os }}-choco-main-

      - name: Install Chocolatey and Essential Tools
        shell: pwsh
        run: |
          Set-ExecutionPolicy Bypass -Scope Process -Force
          try {
            iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
            Write-Host "‚úÖ Chocolatey installed successfully"
          } catch {
            Write-Host "‚ùå Chocolatey installation failed: $($_.Exception.Message)"
          }
          
          # Install essential tools
          $tools = @('tailscale', 'rclone', 'git', '7zip', 'notepadplusplus', 'vscode', 'firefox', 'googlechrome')
          foreach ($tool in $tools) {
            try {
              choco install $tool -y --no-progress --force
              Write-Host "‚úÖ $tool installed successfully"
            } catch {
              Write-Host "‚ö†Ô∏è $tool installation failed: $($_.Exception.Message)"
            }
          }

      - name: Configure RDP with Enhanced Security
        shell: pwsh
        run: |
          try {
            # Enable RDP
            Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name 'fDenyTSConnections' -Value 0 -Force
            Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name 'UserAuthentication' -Value 0 -Force
            
            # Configure firewall
            netsh advfirewall firewall add rule name="RDP-In" protocol=TCP dir=in localport=3389 action=allow profile=any
            
            # Restart Terminal Services
            Restart-Service TermService -Force
            Write-Host "‚úÖ RDP services configured"

            # Create RDP user with retry logic
            $securePass = ConvertTo-SecureString $env:RDP_PASS -AsPlainText -Force
            $maxRetries = 3
            $retryCount = 0
            
            do {
              try {
                if (Get-LocalUser -Name $env:RDP_USER -ErrorAction SilentlyContinue) {
                  Set-LocalUser -Name $env:RDP_USER -Password $securePass -PasswordNeverExpires $true -ErrorAction Stop
                  Write-Host "‚úÖ Updated existing user: $env:RDP_USER"
                } else {
                  New-LocalUser -Name $env:RDP_USER -Password $securePass -FullName 'RDP User' -Description 'Remote Desktop User' -PasswordNeverExpires $true -UserMayNotChangePassword $true -ErrorAction Stop
                  Write-Host "‚úÖ Created new user: $env:RDP_USER"
                }
                
                # Add to groups with error handling
                try { Add-LocalGroupMember -Group 'Administrators' -Member $env:RDP_USER -ErrorAction SilentlyContinue } catch { }
                try { Add-LocalGroupMember -Group 'Remote Desktop Users' -Member $env:RDP_USER -ErrorAction SilentlyContinue } catch { }
                
                Write-Host "‚úÖ User groups configured"
                break
              } catch {
                $retryCount++
                Write-Host "‚ö†Ô∏è User creation attempt $retryCount failed: $($_.Exception.Message)"
                Start-Sleep -Seconds 2
              }
            } while ($retryCount -lt $maxRetries)

            echo "RDP_USER=$env:RDP_USER" >> $env:GITHUB_ENV
          } catch {
            Write-Host "‚ùå RDP configuration failed: $($_.Exception.Message)"
            throw
          }

      - name: Setup Tailscale Connection
        shell: pwsh
        run: |
          try {
            $hostname = "gh-rdp-secondary-$env:GITHUB_RUN_ID-$(Get-Date -Format 'MMddHHmm')"
            
            & "$env:ProgramFiles\Tailscale\tailscale.exe" up --authkey=$env:TAILSCALE_AUTH_KEY --hostname=$hostname --accept-routes --accept-dns
            
            # Wait for IP with timeout
            $timeout = 60
            $elapsed = 0
            $ip = $null
            
            while ($elapsed -lt $timeout -and !$ip) {
              Start-Sleep -Seconds 3
              $elapsed += 3
              try {
                $ip = & "$env:ProgramFiles\Tailscale\tailscale.exe" ip -4
                if ($ip) { break }
              } catch { }
            }
            
            if ($ip) {
              echo "TAILSCALE_IP=$ip" >> $env:GITHUB_ENV
              Write-Host "‚úÖ Tailscale connected: $ip"
              
              # Auto-approve node if API token available
              if ($env:TAILSCALE_API_TOKEN) {
                try {
                  $nodeInfo = & "$env:ProgramFiles\Tailscale\tailscale.exe" status --json | ConvertFrom-Json
                  $nodeId = $nodeInfo.Self.ID
                  if ($nodeId) {
                    $headers = @{ Authorization = "Bearer $env:TAILSCALE_API_TOKEN"; 'Content-Type' = 'application/json' }
                    Invoke-RestMethod "https://api.tailscale.com/api/v2/device/$nodeId/authorized" -Method Post -Headers $headers -Body '{"authorized":true}' -ErrorAction SilentlyContinue
                    Write-Host "‚úÖ Node auto-approved"
                  }
                } catch {
                  Write-Host "‚ö†Ô∏è Auto-approval failed (manual approval may be needed)"
                }
              }
            } else {
              throw "Failed to get Tailscale IP after $timeout seconds"
            }
          } catch {
            Write-Host "‚ùå Tailscale setup failed: $($_.Exception.Message)"
            throw
          }

      - name: Display Connection Information
        shell: pwsh
        run: |
          Write-Host "`n" -ForegroundColor Green
          Write-Host "üéØ RDP CONNECTION DETAILS (SECONDARY WORKFLOW)" -ForegroundColor Green
          Write-Host "===============================================" -ForegroundColor Green
          Write-Host "üåê Tailscale IP: $env:TAILSCALE_IP" -ForegroundColor Yellow
          Write-Host "üë§ Username: $env:RDP_USER" -ForegroundColor Yellow  
          Write-Host "üîê Password: $env:RDP_PASS" -ForegroundColor Yellow
          Write-Host "‚è∞ Active Time: 5 hours 50 minutes" -ForegroundColor Cyan
          Write-Host "üîÑ Sync starts: 5 hours 30 minutes" -ForegroundColor Cyan
          Write-Host "üîÄ Next main starts: 5 hours 50 minutes" -ForegroundColor Cyan
          Write-Host "üì± Connect using RDP client (Android/Windows)" -ForegroundColor White
          Write-Host "üîÑ Seamless handoff from main workflow" -ForegroundColor Magenta
          Write-Host "===============================================" -ForegroundColor Green
          Write-Host "`n" -ForegroundColor Green

      - name: Configure rclone for Google Drive
        shell: pwsh
        run: |
          try {
            $configDir = "$env:USERPROFILE\.config\rclone"
            if (!(Test-Path $configDir)) { 
              New-Item $configDir -ItemType Directory -Force | Out-Null
            }
            
            $configContent = @"
[gdrive]
type = drive
client_id = $env:GOOGLE_CLIENT_ID
client_secret = $env:GOOGLE_CLIENT_SECRET
scope = drive
token = $env:GOOGLE_TOKEN
team_drive = 
"@
            $configContent | Set-Content "$configDir\rclone.conf" -Encoding UTF8
            Write-Host "‚úÖ rclone configuration created"
          } catch {
            Write-Host "‚ùå rclone configuration failed: $($_.Exception.Message)"
            throw
          }

      - name: Setup Persistent Directory and Download Files
        shell: pwsh
        run: |
          try {
            $persistentDir = "C:\Users\runneradmin\Desktop\persistent"
            if (!(Test-Path $persistentDir)) { 
              New-Item $persistentDir -ItemType Directory -Force | Out-Null
            }
            
            Write-Host "üì• Downloading updated files from Google Drive..."
            rclone copy gdrive:/storage $persistentDir --config "$env:USERPROFILE\.config\rclone\rclone.conf" --drive-acknowledge-abuse --drive-skip-gdocs --retries 3 --timeout 15m --progress --transfers 4
            
            Write-Host "‚úÖ Files downloaded to persistent directory"
            
            # Create desktop shortcuts for easy access
            $shell = New-Object -ComObject WScript.Shell
            
            # Shortcut to persistent folder
            $shortcut = $shell.CreateShortcut("C:\Users\runneradmin\Desktop\Persistent Folder.lnk")
            $shortcut.TargetPath = $persistentDir
            $shortcut.Description = "Persistent storage synchronized with Google Drive"
            $shortcut.Save()
            
            Write-Host "‚úÖ Desktop shortcuts created"
          } catch {
            Write-Host "‚ùå Persistent directory setup failed: $($_.Exception.Message)"
          }

      - name: Set Persistent Directory Permissions
        shell: pwsh
        continue-on-error: true
        run: |
          try {
            $folder = "C:\Users\runneradmin\Desktop\persistent"
            $user = $env:RDP_USER
            
            # Wait for user creation to complete
            Start-Sleep -Seconds 5
            
            # Grant permissions using icacls with retry
            $maxRetries = 3
            $retryCount = 0
            
            do {
              try {
                $result = icacls $folder /grant "$($env:COMPUTERNAME)\$user:(OI)(CI)F" /T
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "‚úÖ Permissions granted to $user on $folder"
                  break
                } else {
                  throw "icacls returned exit code $LASTEXITCODE"
                }
              } catch {
                $retryCount++
                Write-Host "‚ö†Ô∏è Permission attempt $retryCount failed: $($_.Exception.Message)"
                if ($retryCount -lt $maxRetries) {
                  Start-Sleep -Seconds 3
                }
              }
            } while ($retryCount -lt $maxRetries)
            
            # Alternative method using PowerShell ACL
            try {
              $acl = Get-Acl $folder
              $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule("$env:COMPUTERNAME\$user", "FullControl", "ContainerInherit,ObjectInherit", "None", "Allow")
              $acl.SetAccessRule($accessRule)
              $acl | Set-Acl $folder
              Write-Host "‚úÖ ACL permissions set as backup method"
            } catch {
              Write-Host "‚ö†Ô∏è ACL backup method failed: $($_.Exception.Message)"
            }
            
          } catch {
            Write-Host "‚ùå Permission setting failed: $($_.Exception.Message)"
          }

      - name: Install VMware Workstation Pro
        shell: pwsh
        run: |
          try {
            $vmwareExe = "C:\Users\runneradmin\Desktop\persistent\VMware-workstation-full-17.6.4-24832109.exe"
            
            if (Test-Path $vmwareExe) {
              Write-Host "üì¶ Installing VMware Workstation Pro..."
              
              # Correct silent install parameters for VMware Workstation
              $arguments = @(
                '/S',                    # Silent install
                '/v"/qn',               # MSI quiet mode  
                'EULAS_AGREED=1',       # Accept EULA
                'AUTOSOFTWAREUPDATE=0', # Disable auto updates
                'DATACOLLECTION=0',     # Disable data collection
                'ADDLOCAL=ALL',         # Install all components
                'REBOOT=ReallySuppress"' # Suppress reboot
              )
              
              $process = Start-Process -FilePath $vmwareExe -ArgumentList $arguments -Wait -PassThru -NoNewWindow
              
              if ($process.ExitCode -eq 0) {
                Write-Host "‚úÖ VMware Workstation Pro installed successfully"
              } else {
                Write-Host "‚ö†Ô∏è VMware installation completed with exit code: $($process.ExitCode)"
              }
              
              # Verify installation
              $vmwareInstallPath = "C:\Program Files (x86)\VMware\VMware Workstation\vmware.exe"
              if (Test-Path $vmwareInstallPath) {
                Write-Host "‚úÖ VMware Workstation Pro installation verified"
              }
              
            } else {
              Write-Host "‚ö†Ô∏è VMware installer not found at $vmwareExe"
              Write-Host "‚ÑπÔ∏è  Please ensure the installer is uploaded to Google Drive storage folder"
            }
          } catch {
            Write-Host "‚ùå VMware installation failed: $($_.Exception.Message)"
          }

      - name: Install Additional Ethical Hacking Tools
        shell: pwsh
        continue-on-error: true
        run: |
          Write-Host "üîß Installing additional tools for educational purposes..."
          
          # Install via Chocolatey (if not already installed)
          $additionalTools = @(
            'nmap',
            'wireshark', 
            'putty',
            'winscp',
            'burp-suite-free-edition',
            'postman',
            'docker-desktop',
            'virtualbox',
            'python3',
            'nodejs',
            'sysinternals'
          )
          
          foreach ($tool in $additionalTools) {
            try {
              choco install $tool -y --no-progress --ignore-checksums --force
              Write-Host "‚úÖ $tool installed"
            } catch {
              Write-Host "‚ö†Ô∏è $tool installation failed"
            }
          }
          
          # Install Python packages for security tools
          try {
            pip install requests beautifulsoup4 scapy netaddr sqlmap
            Write-Host "‚úÖ Python security packages installed"
          } catch {
            Write-Host "‚ö†Ô∏è Python packages installation failed"
          }

      - name: Download Additional Security Tools
        shell: pwsh
        continue-on-error: true
        run: |
          Write-Host "üì• Downloading additional security tools..."
          
          try {
            $toolsDir = "C:\Users\runneradmin\Desktop\SecurityTools"
            New-Item $toolsDir -ItemType Directory -Force | Out-Null
            
            # Download some popular security tools
            $downloads = @{
              "https://live.sysinternals.com/PsExec.exe" = "$toolsDir\PsExec.exe"
              "https://live.sysinternals.com/Procmon.exe" = "$toolsDir\Procmon.exe"
              "https://live.sysinternals.com/TCPView.exe" = "$toolsDir\TCPView.exe"
            }
            
            foreach ($url in $downloads.Keys) {
              try {
                Invoke-WebRequest -Uri $url -OutFile $downloads[$url] -UseBasicParsing -TimeoutSec 30
                Write-Host "‚úÖ Downloaded $(Split-Path $downloads[$url] -Leaf)"
              } catch {
                Write-Host "‚ö†Ô∏è Failed to download $(Split-Path $downloads[$url] -Leaf)"
              }
            }
            
            # Create shortcut to tools folder
            $shell = New-Object -ComObject WScript.Shell
            $shortcut = $shell.CreateShortcut("C:\Users\runneradmin\Desktop\Security Tools.lnk")
            $shortcut.TargetPath = $toolsDir
            $shortcut.Description = "Security and penetration testing tools"
            $shortcut.Save()
            
            Write-Host "‚úÖ Security tools setup completed"
          } catch {
            Write-Host "‚ùå Security tools download failed: $($_.Exception.Message)"
          }

      # Main active period - wait until 5.5 hours (19800 seconds)
      - name: Active RDP Session (5 hours 30 minutes)
        shell: pwsh
        run: |
          Write-Host "üü¢ Secondary RDP session is now active for 5 hours 30 minutes..."
          Write-Host "üì± You can now connect using the details shown above"
          Write-Host "‚è∞ Sync will start automatically in 5 hours 30 minutes"
          Write-Host "üîÑ Next main workflow will start in 5 hours 50 minutes"
          Write-Host ""
          Write-Host "üõ†Ô∏è  Available tools installed:"
          Write-Host "   - VMware Workstation Pro (if installer was available)"
          Write-Host "   - Visual Studio Code"
          Write-Host "   - Git & development tools"
          Write-Host "   - Chrome & Firefox browsers" 
          Write-Host "   - Network security tools (nmap, wireshark)"
          Write-Host "   - System tools (Sysinternals suite)"
          Write-Host "   - Penetration testing tools"
          Write-Host "   - Python with security packages"
          Write-Host ""
          Write-Host "üéØ This session continues seamlessly from the main workflow"
          Write-Host ""
          
          Start-Sleep -Seconds 19800  # 5.5 hours

      - name: Pre-sync Preparation
        shell: pwsh
        run: |
          Write-Host "üîÑ Starting sync preparation (30 minutes remaining)..."
          
          # Final sync from persistent directory
          try {
            $persistentDir = "C:\Users\runneradmin\Desktop\persistent"
            Write-Host "üì§ Syncing local changes to Google Drive..."
            
            rclone bisync $persistentDir gdrive:/storage --config "$env:USERPROFILE\.config\rclone\rclone.conf" --drive-acknowledge-abuse --drive-skip-gdocs --resync --resilient --create-empty-src-dirs --retries 5 --timeout 20m --progress --transfers 4 --checkers 8
            
            Write-Host "‚úÖ Sync completed successfully"
          } catch {
            Write-Host "‚ùå Sync failed: $($_.Exception.Message)"
          }

      # Wait until 5 hours 50 minutes (21000 seconds total) to trigger next main
      - name: Wait for Next Main Workflow Trigger Time
        shell: pwsh
        run: |
          Write-Host "‚è≥ Waiting until 5 hours 50 minutes to trigger next main workflow..."
          Start-Sleep -Seconds 1200  # 20 minutes (from 5:30 to 5:50)

      - name: Trigger Next Main Workflow
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            console.log('üöÄ Triggering next main workflow to continue cycle...');
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner
